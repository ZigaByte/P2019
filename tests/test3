fun putInt(n:int):void;
fun putChar(c:char):void;
fun putString(s:ptr char):void;

fun main():int = {
	t2d = new(arr[9] arr[9] int);
	t1d=(t2d:ptr arr[81] int);
	putString("haha");
	
	(@t1d)[0]=0;
	
	:0
	where
		var t2d:ptr arr[9] arr[9] int;
		var t1d:ptr arr[81] int;

};



fun main():int = {
	x = 1100000;
	sub1();
	
	:0
	where 
	var x:int;
	fun sub1():void={
		x = 555555555555;
		putInt(x);
	:none};
};

fun putInt(n:int):void;
fun putChar(c:char):void;
fun putString(s:ptr char):void;
















fun putInt(n:int):void;
fun putChar(c:char):void;
fun putString(s:ptr char):void;

fun main():int =
    {
      putString("BinTree:"); 
      putChar((10:char));
      { 
		    t=(null:bintree); 
		    printBT(t); putChar((10:char));
			t=insBT(5,t); 
			
		    putString("Hello2");
			printBT(t); 
			putChar((10:char));
			t=insBT(7,t); printBT(t); putChar((10:char));
			t=insBT(8,t); printBT(t); putChar((10:char));
			t=insBT(2,t); printBT(t); putChar((10:char));
			t=insBT(6,t); printBT(t); putChar((10:char));
		        t=delBT(8,t); printBT(t); putChar((10:char));
      : none
      	where var t:bintree;
      };
      
      : 0
    where
      var n:int; var m:int;
    };

typ bintree:ptr binnode;
typ binnode:rec(i:int,lth:bintree,gth:bintree);

fun printBT(t:bintree):void =
    { if t==(null:bintree) then
        putChar('$');
      else
        putInt((@t).i);
	putChar('(');
	printBT((@t).lth);
	putChar(',');
	printBT((@t).gth);
	putChar(')');
      end;
    : none
    };

fun insBT(i:int,t:bintree):bintree ={

	if t==(null:bintree) then
		t=new(binnode);
    	putString("Hello1");
    	(@t);
    	putString("Hello2");
    	
		(@t).i=i;
		(@t).lth=(null:bintree);
		(@t).gth=(null:bintree);
	else
		if (@t).i!=i then
			if i<(@t).i then 
				(@t).lth=insBT(i,(@t).lth);
			else 
				(@t).gth=insBT(i,(@t).gth);
			end;
		end;
	end;
: t
};

fun delBT(i:int,t:bintree):bintree =
    { if t!=(null:bintree) then
        if (@t).i==i then
	  if (@t).lth==(null:bintree)&(@t).gth==(null:bintree) then
	    del(t);
	    t=(null:bintree);
	  else
	    if (@t).lth!=(null:bintree) then
	      { max=maxBT((@t).lth);
		(@t).i=@max;
		(@t).lth=delBT(@max,(@t).lth);
              : none
              where var max:ptr int;
	      };
	    else
	      { min=minBT((@t).lth);
	        (@t).i=@min;
		(@t).gth=delBT(@min,(@t).gth);
	      : none
	      where var min:ptr int;
	      };
	    end;
	  end;
	else
	  if i<(@t).i
	    then (@t).lth=delBT(i,(@t).lth);
	    else (@t).gth=delBT(i,(@t).gth);
	  end;
	end;
      end;
    : t
    };

fun minBT(t:bintree):ptr int =
    {
      if t==(null:bintree) then
        min=(null:ptr int);
      else
        if (@t).lth==(null:bintree) then
          min=$((@t).i);
	else
	  min=minBT((@t).gth);
	end;
      end;
    : min
    where
      var min:ptr int;
    };

fun maxBT(t:bintree):ptr int =
    {
      if t==(null:bintree) then
        max=(null:ptr int);
      else
        if (@t).gth==(null:bintree) then
	  max=$((@t).i);
	else
	  max=maxBT((@t).gth);
	end;
      end;
    : max
    where
      var max:ptr int;
    };

fun sudoku(t2d:ptr arr[9] arr[9] int):int =
    { t1d=(t2d:ptr arr[81] int);
    : solve(0,81)
    where
      var t1d:ptr arr[81] int;
      fun check_h(j:int):bool =
          { check=true;
	    i=1; while i<=9 do mask[i]=false; i=i+1; end;
	    i=0;
	    while i<9 do
	      if (@t2d)[j][i]!=0 then
	        if mask[(@t2d)[j][i]]
		  then check=false;
		  else mask[(@t2d)[j][i]]=true;
		end;
	      end;
	      i=i+1;
	    end;
	  : check
	  where
	    var mask:arr[10] bool;
	    var i:int;
	    var check:bool;
	  };
      fun check_v(i:int):bool =
          { check=true;
	    j=1; while j<=9 do mask[j]=false; j=j+1; end;
	    j=0;
	    while j<9 do
	      if (@t2d)[j][i]!=0 then
	        if mask[(@t2d)[j][i]]
		  then check=false;
		  else mask[(@t2d)[j][i]]=true;
		end;
	      end;
	      j=j+1;
	    end;
	  : check
	  where
	    var mask:arr[10] bool;
	    var j:int;
	    var check:bool;
	  };
      fun check_q(i:int,j:int):bool =
          { check=true;
	    k=1; while k<=9 do mask[k]=false; k=k+1; end;
	    jj=0;
	    while jj<3 do
	      ii=0;
	      while ii<3 do
	        if (@t2d)[j*3+jj][i*3+ii]!=0 then
		  if mask[(@t2d)[j*3+jj][i*3+ii]]
		    then check=false;
		    else mask[(@t2d)[j*3+jj][i*3+ii]]=true;
		  end;
		end;
	        ii=ii+1;
	      end;
	      jj=jj+1;
	    end;
	  : check
	  where
	    var mask:arr[10] bool;
	    var ii:int;
	    var jj:int;
	    var k:int;
	    var check:bool;
	  };
      fun solve(k:int,n:int):int =
          { if k==n then
	      { if true then
	          j=0;
	          while j<9 do
		    i=0;
		    while i<9 do
		      putInt((@t2d)[j][i]);
		      putChar(' ');
		      i=i+1;
		    end;
		    putChar((10:char));
		    j=j+1;
		  end;
		  putChar((10:char));
		end;
	      : none
	      where
	        var j:int;
		var i:int;
	      };
	      count=1;
	    else
	      if (@t1d)[k]!=0 then
	        count=solve(k+1,n);
              else
		{ count = 0;
		  d=1;
		  while d<=9 do
		    (@t1d)[k]=d;
		    if check_h(k/9)&check_v(k%9)&check_q((k/9)/3,(k%9)/3) then
		      count=count+solve(k+1,n);
		    end;
		    (@t1d)[k]=0;
		    d=d+1;
		  end;
		: none
		where
		  var d:int;
		};
	      end;
	    end;
	  : count
	  where
	    var count:int;
	  };
    };
